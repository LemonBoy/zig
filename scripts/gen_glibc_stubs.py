#!/usr/bin/python3
import sys
import string
from distutils.version import LooseVersion

def is_reserved_kw(s):
    return s in ['error']

if len(sys.argv) < 4:
    print('{} output_name default_version [input files...]'.format(sys.argv[0]))
    sys.exit(1)

# Don't use any symbol newer than this version as default one
# Use LooseVersion because it handles the presence of the GLIBC_ prefix
base_version = LooseVersion(sys.argv[2])

# Association between each symbol and the library version it's defined in
symbol_map = {}
# A set of unique library versions
version_set = set()
# A set of unique symbol names to generate the stubs for
stub_symbols = set()

# Build a map of per-version unique symbols
for file in sys.argv[3:]:
    for line in open(file):
        (version, symbol, type, *size) = line.strip().split()
        if symbol in symbol_map:
            symbol_map[symbol].append(version)
        else:
            symbol_map[symbol] = [version]
        version_set.add(version)

with open(sys.argv[1] + '.zig', 'w') as outf_zig:
    outf_zig.write('// AUTOGENERATED FILE - DO NOT EDIT DIRECTLY\n\n')

    # Generate the symver directives
    outf_zig.write('comptime {\n')
    outf_zig.write('    asm (\n')
    for sym in sorted(symbol_map.keys()):
        def_version_list = sorted(map(LooseVersion, symbol_map[sym]))

        # Pick the default symbol version:
        # - If the version string doesn't start with GLIB_ then don't pick any
        #   default version
        # - If there's just one version take it
        # - If there's more than one version take the greatest one <= than the
        #   specified one
        # - If there's more than one version and none of them is <= than the
        #   specified one don't pick any default version
        def_version = None
        if str(def_version_list[0]).startswith('GLIBC_'):
            if len(def_version_list) == 1:
                def_version = def_version_list[0]
            else:
                for v in def_version_list:
                    if v <= base_version:
                        def_version = v

        for version in def_version_list:
            # Turn GLIBC_X.Y.Z into _X_Y_Z
            suffix = str(version).strip(string.ascii_letters).replace('.', '_')
            stub_name = sym + suffix

            stub_symbols.add(stub_name)

            if def_version and version == def_version:
                # Default symbol version definition
                outf_zig.write('        \\\\ .symver {}, {}@@{}\n'.format(
                    stub_name, sym, version))
            else:
                # Normal symbol version definition
                outf_zig.write('        \\\\ .symver {}, {}@{}\n'.format(
                    stub_name, sym, version))

            # Hide the stub to keep the symbol table clean
            outf_zig.write('        \\\\ .hidden {}\n'.format(stub_name))
    outf_zig.write('    );\n')
    outf_zig.write('}\n')

    # Generate the stubs
    for sym in sorted(stub_symbols):
        fn_sym = sym
        if is_reserved_kw(fn_sym):
            fn_sym = '@"{}"'.format(symbol)
        outf_zig.write('export fn {}() void {{}}\n'.format(fn_sym))

# Generate the version script
with open(sys.argv[1] + '.map', 'w') as outf_map:
    outf_map.write('# AUTOGENERATED FILE - DO NOT EDIT DIRECTLY\n\n')
    for ver in sorted(version_set, key=LooseVersion):
        outf_map.write(ver)
        outf_map.write(' { };\n')
